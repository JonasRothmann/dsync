use indoc::indoc;
use inflector::Inflector;

use crate::parser::{ParsedTableMacro, RelationType, FILE_SIGNATURE};
use crate::{EnsureNonExisting, EnsureNonKeyword, GenerationConfig, TableOptions};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum StructType {
    /// Variant for the `Read` struct which can be queried and has all properties
    Read,
    /// Variant for a `Update*` struct, which has all properties wrapped in [`Option<>`]
    Update,
    /// Variant for a `Create` struct, which only has all the properties which are not autogenerated
    Create,
}

impl StructType {
    /// Get the prefix for the current [StructType]
    ///
    /// Example: `UpdateTodos`
    pub fn prefix(&self) -> &'static str {
        match self {
            StructType::Read => "",
            StructType::Update => "Update",
            StructType::Create => "Create",
        }
    }

    /// Get the suffix for the current [StructType]
    ///
    /// Example: `TodosForm`
    pub fn suffix(&self) -> &'static str {
        match self {
            StructType::Read => "",
            StructType::Update => "",
            StructType::Create => "",
        }
    }

    /// Format a struct with all prefix- and suffixes
    ///
    /// Example: `UpdateTodos`
    pub fn format(&self, name: &str) -> String {
        format!(
            "{struct_prefix}{struct_name}{struct_suffix}",
            struct_prefix = self.prefix(),
            struct_name = name,
            struct_suffix = self.suffix()
        )
        .ensure_non_existing()
    }
}

#[derive(Debug)]
struct Struct<'a> {
    /// Struct name (like `UpdateTodos`)
    identifier: String,
    /// Type of the Struct
    ty: StructType,
    /// Parsed table reference
    table: &'a ParsedTableMacro,
    /// Generation options specific for the current table
    opts: TableOptions<'a>,
    /// Global generation options
    config: &'a GenerationConfig<'a>,
    /// Storage for the finished generated code
    rendered_code: Option<String>,
    /// Cache for if this struct even has any fields
    has_fields: Option<bool>, // note: this is only correctly set after a call to render() which gets called in Struct::new()
}

#[derive(Debug, Clone)]
pub struct StructField {
    /// Name for the field
    // TODO: should this be a Ident instead of a string?
    pub name: String,
    /// Rust type of the final field
    pub base_type: String,

    pub is_optional: bool,

    pub macros: Vec<String>,
}

impl<'a> Struct<'a> {
    /// Create a new instance
    pub fn new(
        ty: StructType,
        table: &'a ParsedTableMacro,
        config: &'a GenerationConfig<'_>,
    ) -> Self {
        println!("Generating struct for table {}", table.name.to_string());

        let mut obj = Self {
            identifier: ty.format(table.struct_name.as_str()),
            opts: config.table(&table.name.to_string()),
            table,
            ty,
            config,
            rendered_code: None,
            has_fields: None,
        };
        obj.render();
        obj
    }

    /// Get the rendered code, or a empty string
    pub fn code(&self) -> &str {
        self.rendered_code.as_deref().unwrap_or_default()
    }

    /// Get if the current struct has fields
    ///
    /// Currently panics if [`render`](#render) has not been called yet
    pub fn has_fields(&self) -> bool {
        self.has_fields.unwrap()
    }

    fn attr_tsync(&self) -> &'static str {
        #[cfg(feature = "tsync")]
        match self.opts.get_tsync() {
            true => "#[tsync::tsync]\n",
            false => "",
        }
        #[cfg(not(feature = "tsync"))]
        ""
    }

    /// Assemble all derives for the struct
    fn attr_derive(&self) -> String {
        format!("#[derive(Debug, {derive_serde}Clone, Queryable, Insertable{derive_aschangeset}{derive_identifiable}{derive_associations}{derive_selectable}{derive_default}, new)]",
                derive_selectable = match self.ty {
                    StructType::Read => { ", Selectable" }
                    _ => { "" }
                },
                derive_associations = match self.ty {
                    StructType::Read => {
                        if !self.table.foreign_keys.is_empty() { ", Associations" } else { "" }
                    }
                    _ => { "" }
                },
                derive_identifiable = match self.ty {
                    StructType::Read => {
                        if !self.table.foreign_keys.is_empty() { ", Identifiable" } else { "" }
                    }
                    _ => { "" }
                },
                derive_aschangeset = if self.fields().iter().all(|f| self.table.primary_key_column_names().contains(&f.name)) {""} else { "" },
                derive_default = match self.ty {
                    StructType::Update => { ", Default" }
                    _ => { "" }
                },
                derive_serde = if self.config.table(&self.table.name.to_string()).get_serde() {
                    "Serialize, Deserialize, "
                } else { "" }
        )
    }

    /// Assemble all fields the struct will have
    fn fields(&self) -> Vec<StructField> {
        self.table
            .columns
            .iter()
            .filter(|c| {
                let is_autogenerated = self
                    .opts
                    .autogenerated_columns
                    .as_deref()
                    .unwrap_or_default()
                    .contains(&c.name.to_string().as_str());

                match self.ty {
                    StructType::Read => true,
                    StructType::Update => {
                        let is_pk = self.table.primary_key_columns.contains(&c.name);

                        !is_pk
                    }
                    StructType::Create => !is_autogenerated,
                }
            })
            .map(|c| {
                let name = c.name.to_string().to_snake_case().ensure_non_keyword();
                let base_type = if c.is_unsigned {
                    c.ty.replace('i', "u")
                } else {
                    c.ty.clone()
                };
                let base_type = if c.is_nullable {
                    format!("Option<{}>", base_type)
                } else {
                    base_type
                };
                let mut is_optional = false;

                let mut macros = vec![];
                if name != c.name.to_string() {
                    macros.push(format!(
                        "#[diesel(column_name = \"{}\")]",
                        c.name.to_string()
                    ));
                }
                if c.is_nullable {
                    macros.push("#[new(default)]".to_string());
                }

                let is_pk = self
                    .table
                    .primary_key_columns
                    .iter()
                    .any(|pk| pk.to_string().eq(name.as_str()));
                let is_autogenerated = self
                    .opts
                    .autogenerated_columns
                    .as_deref()
                    .unwrap_or_default()
                    .contains(&c.name.to_string().as_str());
                // let is_fk = table.foreign_keys.iter().any(|fk| fk.1.to_string().eq(field_name.as_str()));

                match self.ty {
                    StructType::Read => {}
                    StructType::Update => {
                        // all non-key fields should be optional in Form structs (to allow partial updates)
                        is_optional = !is_pk || is_autogenerated;
                    }
                    StructType::Create => {}
                }

                StructField {
                    name,
                    base_type,
                    is_optional,
                    macros,
                }
            })
            .collect()
    }

    /// Render the full struct
    fn render(&mut self) {
        let ty = self.ty;
        let table = &self.table;

        let primary_keys: Vec<String> = table.primary_key_column_names();

        let belongs_to = table
            .foreign_keys
            .iter()
            .map(|fk| {
                format!(
                    ", belongs_to({foreign_table_name}, foreign_key={join_column})",
                    foreign_table_name = fk.0.to_string().to_pascal_case(), //.to_singular(),
                    join_column = fk.1
                )
            })
            .collect::<Vec<String>>()
            .join(" ");

        let struct_code = format!(
            indoc! {r#"
            {tsync_attr}{derive_attr}
            #[diesel(table_name=schema::{table_name}{primary_key}{belongs_to})]
            pub struct {struct_name} {{
            $COLUMNS$
            }}
        "#},
            tsync_attr = self.attr_tsync(),
            derive_attr = self.attr_derive(),
            table_name = table.name,
            struct_name = ty.format(&table.struct_name),
            primary_key = if ty != StructType::Read {
                "".to_string()
            } else {
                format!(", primary_key({})", primary_keys.join(","))
            },
            belongs_to = if ty != StructType::Read {
                "".to_string()
            } else {
                belongs_to
            }
        );

        let fields = self.fields();
        let mut lines = vec![];
        for f in fields.iter() {
            let field_name = &f.name;
            let field_type = if f.is_optional {
                format!("Option<{}>", f.base_type)
            } else {
                f.base_type.clone()
            };

            for m in &f.macros {
                lines.push(format!("    {}", m));
            }

            lines.push(format!(r#"    pub {field_name}: {field_type},"#));
        }

        if fields.is_empty() {
            self.has_fields = Some(false);
            self.rendered_code = Some("".to_string());
        } else {
            self.has_fields = Some(true);
            self.rendered_code = Some(struct_code.replace("$COLUMNS$", &lines.join("\n")));
        }
    }
}

/// Generate all functions (insides of the `impl StuctName { here }`)
fn build_table_fns(
    table: &ParsedTableMacro,
    config: &GenerationConfig,
    create_struct: Struct,
    update_struct: Struct,
) -> String {
    let table_options = config.table(&table.name.to_string());

    let primary_column_name_and_type: Vec<(String, String)> = table
        .primary_key_columns
        .iter()
        .map(|pk| {
            let col = table
                .columns
                .iter()
                .find(|it| it.name.to_string().eq(pk.to_string().as_str()))
                .expect("Primary key column doesn't exist in table");

            (col.name.to_string(), col.ty.to_string())
        })
        .collect();

    let item_id_params = primary_column_name_and_type
        .iter()
        .map(|name_and_type| {
            format!(
                "param_{name}: {ty}",
                name = name_and_type.0,
                ty = name_and_type.1
            )
        })
        .collect::<Vec<String>>()
        .join(", ");

    // return tuple if multiple
    let primary_keys_multiple = primary_column_name_and_type.len() > 1;
    let primary_key_type = if primary_column_name_and_type.is_empty() {
        None
    } else if primary_keys_multiple {
        Some(format!(
            "({})",
            primary_column_name_and_type
                .iter()
                .map(|it| it.1.to_string())
                .collect::<Vec<String>>()
                .join(", ")
        ))
    } else {
        Some(primary_column_name_and_type[0].1.to_string())
    };

    // takes the primary key (can be tuple or other type), and generates diesel filter for it
    let primary_key_filter = if primary_column_name_and_type.len() > 0 {
        let contents = primary_column_name_and_type
            .iter()
            .enumerate()
            .map(|(index, name_and_type)| {
                format!(
                    "filter({name}.eq({value}))",
                    name = name_and_type.0.to_string(),
                    value = if primary_column_name_and_type.len() > 1 {
                        format!("cursor.{index}", index = index)
                    } else {
                        "cursor".to_string()
                    }
                )
            })
            .collect::<Vec<String>>()
            .join(".");

        Some(contents)
    } else {
        None
    };

    let item_id_filters = primary_column_name_and_type
        .iter()
        .map(|name_and_type| {
            format!(
                "filter({name}.eq(param_{name}))",
                name = name_and_type.0.to_string()
            )
        })
        .collect::<Vec<String>>()
        .join(".");

    // template variables
    let table_name = table.name.to_string();
    #[cfg(feature = "tsync")]
    let tsync = match table_options.get_tsync() {
        true => "#[tsync::tsync]",
        false => "",
    };
    #[cfg(not(feature = "tsync"))]
    let tsync = "";
    #[cfg(feature = "async")]
    let async_keyword = if table_options.get_async() {
        " async"
    } else {
        ""
    };
    #[cfg(not(feature = "async"))]
    let async_keyword = "";
    #[cfg(feature = "async")]
    let await_keyword = if table_options.get_async() {
        ".await"
    } else {
        ""
    };
    #[cfg(not(feature = "async"))]
    let await_keyword = "";
    let struct_name = table.struct_name.clone().ensure_non_existing();
    let schema_path = &config.schema_path;
    let create_struct_identifier = &create_struct.identifier;
    let update_struct_identifier = &update_struct.identifier;
    let item_id_params = item_id_params;
    let item_id_filters = item_id_filters;
    let serde_derive = if table_options.get_serde() {
        "Serialize"
    } else {
        ""
    };

    let mut buffer = String::new();

    if config.generates_offset_pagination {
        buffer.push_str(&format!(
            r##"{tsync}
#[derive(Debug, {serde_derive})]
pub struct PaginationResult<T> {{
    pub items: Vec<T>,
    pub total_items: i64,
    /// 0-based index
    pub page: i64,
    pub page_size: i64,
    pub num_pages: i64,
}}
"##
        ));
    }

    if config.generates_cursor_pagination {
        buffer.push_str(&format!(
            r##"{tsync}
#[derive(Debug, {serde_derive})]
pub struct CursorPaginationResult<T, K> {{
    pub items: Vec<T>,
    pub start_cursor: Option<K>,
    pub end_cursor: Option<K>,
    pub has_previous_page: bool,
    pub has_next_page: bool,
}}
"##
        ));
    }

    buffer.push_str(&format!(
        r##"
impl {struct_name} {{
"##
    ));

    if config.generates_crud {
        if create_struct.has_fields() {
            buffer.push_str(&format!(
            r##"
    pub{async_keyword} fn create(db: &mut ConnectionType, item: &{create_struct_identifier}) -> QueryResult<Self> {{
        use {schema_path}{table_name}::dsl::*;

        insert_into({table_name}).values(item).get_result::<Self>(db){await_keyword}
    }}
"##
        ));
        } else {
            buffer.push_str(&format!(
                r##"
    pub{async_keyword} fn create(db: &mut ConnectionType) -> QueryResult<Self> {{
        use {schema_path}{table_name}::dsl::*;

        insert_into({table_name}).default_values().get_result::<Self>(db){await_keyword}
    }}
"##
            ));
        }

        buffer.push_str(&format!(
            r##"
    pub{async_keyword} fn read(db: &mut ConnectionType, {item_id_params}) -> QueryResult<Self> {{
        use {schema_path}{table_name}::dsl::*;

        {table_name}.{item_id_filters}.first::<Self>(db){await_keyword}
    }}
"##
        ));

        buffer.push_str(&format!(
            r##"
    pub{async_keyword} fn delete(db: &mut ConnectionType, {item_id_params}) -> QueryResult<usize> {{
        use {schema_path}{table_name}::dsl::*;

        diesel::delete({table_name}.{item_id_filters}).execute(db){await_keyword}
    }}
"##
        ));
    }

    // Offset pagination
    if config.generates_offset_pagination {
        buffer.push_str(&format!(r##"
    /// Paginates through the table where page is a 0-based index (i.e. page 0 is the first page)
    pub{async_keyword} fn paginate(db: &mut ConnectionType, page: i64, page_size: i64) -> QueryResult<PaginationResult<Self>> {{
        use {schema_path}{table_name}::dsl::*;

        let page_size = if page_size < 1 {{ 1 }} else {{ page_size }};
        let total_items = {table_name}.count().get_result(db){await_keyword}?;
        let items = {table_name}.limit(page_size).offset(page * page_size).load::<Self>(db){await_keyword}?;

        Ok(PaginationResult {{
            items,
            total_items,
            page,
            page_size,
            /* ceiling division of integers */
            num_pages: total_items / page_size + i64::from(total_items % page_size != 0)
        }})
    }}
"##));
    }

    // Cursor-based pagination
    if let Some(primary_key_type) = &primary_key_type {
        if let Some(primary_key_filter) = &primary_key_filter {
            if config.generates_cursor_pagination {
                buffer.push_str(&format!(r##"
    /// Paginates through the table based on a cursor
    pub{async_keyword} fn paginate_cursor(db: &mut ConnectionType, limit: i64, cursor: {primary_key_type}) -> QueryResult<CursorPaginationResult<Self, {primary_key_type}>> {{
        use {schema_path}{table_name}::dsl::*;

        let limit = if limit < 1 {{ 1 }} else {{ limit }};
        let items = {table_name}.{primary_key_filter}.limit(limit).load::<Self>(db){await_keyword}?;

        let start_cursor = items.first().map(|it| {primary_key_mapping});
        let end_cursor = items.last().map(|it| {primary_key_mapping});

        let has_previous_page = start_cursor.is_some();
        let has_next_page = end_cursor.is_some();

        Ok(CursorPaginationResult {{
            items,
            start_cursor,
            end_cursor,
            has_previous_page,
            has_next_page,
        }})
    }}
"##, primary_key_mapping = if primary_keys_multiple {
    format!(
        "({})",
        primary_column_name_and_type
            .iter()
            .map(|name_and_type| format!("it.{name}", name = name_and_type.0))
            .collect::<Vec<String>>()
            .join(", ")
    )
} else {
    if primary_column_name_and_type.len() > 0 {
        format!("it.{name}", name = primary_column_name_and_type[0].0).to_string()
    } else {
        panic!("Primary key type is None")
    }
}));
            }
        }
    }

    buffer.push_str(
        r##"
}"##,
    );

    if let Some(primary_key_type) = &primary_key_type {
        if config.generates_dataloader {
            let batcher_name = format!("{}Batcher", struct_name.to_pascal_case());
            let loader_name = format!("{}Loader", struct_name.to_pascal_case());
            let batcher_param_filter = if primary_keys_multiple {
                primary_column_name_and_type
                    .iter()
                    .enumerate()
                    .map(|(index, (column_name, ty))| {
                        format!("filter({name}.eq_any(keys.iter().map(|key| &key.{index}).collect::<Vec<_>>()))", name = column_name)
                    })
                    .collect::<Vec<String>>()
                    .join(".")
            } else {
                format!(
                    "filter({name}.eq_any(keys))",
                    name = primary_column_name_and_type[0].0
                )
            };

            let batcher_keys_map = if primary_keys_multiple {
                primary_column_name_and_type
                    .iter()
                    .map(|(column_name, _)| {
                        format!("e.{name}.clone()", name = column_name.to_snake_case())
                    })
                    .collect::<Vec<String>>()
                    .join(", ")
            } else {
                format!("e.{name}.clone()", name = primary_column_name_and_type[0].0)
            };

            buffer.push_str(&format!(r##"
pub struct {batcher_name} {{
    pool: Pool
}}

pub type {loader_name} = Loader<{primary_key_type}, {struct_name}, {batcher_name}>;

impl {batcher_name} {{
    pub fn new(pool: Pool) -> {loader_name} {{
        Loader::new(Self {{ pool }})
    }}
}}

#[async_trait]
impl BatchFn<{primary_key_type}, {struct_name}> for {batcher_name} {{
    async fn load(&mut self, keys: &[{primary_key_type}]) -> HashMap<{primary_key_type}, {struct_name}> {{
        use {schema_path}{table_name}::dsl::*;
        
        let conn = &mut self.pool.get().unwrap();

        println!("load {struct_name} by batch {{:?}}", keys);

        {table_name}
            .{batcher_param_filter}
            .select(super::{struct_name}::as_select())
            .load::<super::{struct_name}>(conn)
            .expect("Error loading {batcher_name}")
            .into_iter()
            .map(|e| (({batcher_keys_map}), e))
            .collect()
    }}
}}
        "##));
        };
    }

    /*
        if table.relations.len() > 0 {
            let relations = table
                .relations
                .iter()
                .map(|rel| {
                    format!(
                        r#"
    #[hansa({derive})]
    pub {relation_name},
    "#,
                        relation_name = rel.table2.to_string().to_snake_case(),
                        derive = match rel.relation_type {
                            RelationType::OneToOne { table1_column } => {
                                format!("has_one={table1}, join_column=,", table1 = rel.table1)
                            }
                            RelationType::ManyToMany {
                                join_table,
                                table1_join_column,
                                table2_join_column,
                            } => {
                                format!("has_many={table2}", table2 = rel.table2,)
                            }
                        }
                        .to_string()
                    )
                })
                .collect::<Vec<String>>()
                .join(", ");

            buffer.push_str(&format!(
                r##"
    pub enum Relations {{
        {relations}
    }}
            "##
            ));
        }
         */

    buffer
}
/// Generate all imports for the struct file that are required
fn build_imports(table: &ParsedTableMacro, config: &GenerationConfig) -> String {
    let table_options = config.table(&table.name.to_string());
    let belongs_imports = table
        .foreign_keys
        .iter()
        .map(|fk| {
            format!(
                "use {model_path}{foreign_table_name_model}::{singular_struct_name};",
                foreign_table_name_model = fk.0.to_string().to_snake_case(),
                singular_struct_name = fk.0.to_string().to_pascal_case(), //.to_singular(),
                model_path = config.model_path
            )
        })
        .collect::<Vec<String>>()
        .join("\n");
    #[cfg(feature = "async")]
    let async_imports = if table_options.get_async() {
        "\nuse diesel_async::RunQueryDsl;"
    } else {
        ""
    };
    #[cfg(not(feature = "async"))]
    let async_imports = "";

    let mut schema_path = config.schema_path.clone();
    //schema_path.push('*'); -- this breaks with upper-case table names
    schema_path.push_str("{self}");

    let serde_imports = if table_options.get_serde() {
        "use serde::{Deserialize, Serialize};"
    } else {
        ""
    };

    let fns_imports = if table_options.get_fns() {
        "\nuse diesel::QueryResult;"
    } else {
        ""
    };

    let connection_type_alias = if table_options.get_fns() {
        format!(
            "\ntype ConnectionType = {connection_type};\ntype Pool = {pool_type};",
            connection_type = config.connection_type,
            pool_type = config.pool_type
        )
    } else {
        "".to_string()
    };

    let dataloader_imports = if config.generates_dataloader {
        r#"
use async_trait::async_trait;
use dataloader::cached::Loader;
use dataloader::BatchFn;
use std::collections::HashMap;
"#
    } else {
        ""
    };

    format!(
        indoc! {"
        use crate::diesel::*;
        use {schema_path};{fns_imports}
        {serde_imports}{async_imports}
        {belongs_imports}
        {connection_type_alias}
        {dataloader_imports}
    "},
        belongs_imports = belongs_imports,
        async_imports = async_imports,
        schema_path = schema_path,
        serde_imports = serde_imports,
        fns_imports = fns_imports,
        connection_type_alias = connection_type_alias,
        dataloader_imports = dataloader_imports
    )
    .trim_end()
    .to_string()
}

/// Generate a full file for a given diesel table
pub fn generate_for_table(table: &ParsedTableMacro, config: &GenerationConfig) -> String {
    let table_options = config.table(&table.name.to_string());
    // first, we generate struct code
    let read_struct = Struct::new(StructType::Read, table, config);
    let update_struct = Struct::new(StructType::Update, table, config);
    let create_struct = Struct::new(StructType::Create, table, config);

    let mut structs = String::new();
    structs.push_str(read_struct.code());
    structs.push('\n');
    structs.push_str(create_struct.code());
    structs.push('\n');
    structs.push_str(update_struct.code());

    let functions = if table_options.get_fns() {
        build_table_fns(table, config, create_struct, update_struct)
    } else {
        "".to_string()
    };
    let imports = build_imports(table, config);

    format!("{FILE_SIGNATURE}\n\n{imports}\n\n{structs}\n{functions}")
}
